---
title: "03 Resumen descomposición"
author: "Eddie Aguilar"
format:
  html:
    self-contained: true
editor: source
---

Patrones de una serie de tiempo:

-   Tendencia (Tendencia y ciclos)
-   Estacionalidad
-   Residuo (Lo que no es parte de ninguno)

```{r}
#| message: false
library("tidyverse")
library("fpp3")
library("tidyquant")
library("timetk")
library("patchwork")
library("scales")
library("fpp2")
```

# Transformaciones y ajustes

Hay que hacer ajustes a los datos para hacerlos lo más sencillos posibles y tener un mejor análisis.

## Ajustes de calendario

```{r}
transacciones_mensuales <- tq_get("GOOG", get = "stock.prices",
                                  from = "2015-01-01") %>% 
summarise_by_time(
    .date_var      =  date, 
    .by            = "month",
    monthly_volume = sum(volume),
    trading_days   = n(),
    mean_volume    = mean(volume)) %>%
  mutate(month     = yearmonth(date)) %>% 
  select(month, everything(), -date) %>% 
  as_tsibble(index = month)

transacciones_mensuales
```

Graficar tanto el volumen mensual total como el volumen mensual promedio. Hay dos opciones:

1.  Se grafican por seperado y posteriormente se imprimen ambas.
2.  Se usa pivot_longer para juntar ambas variables y sus valores en una sola columna y se usa facet_wrap().

```{r}
# Opción 1
p1 <- ggplot(data = transacciones_mensuales) + 
  geom_line(aes(x = month, y = monthly_volume)) +
  ylab("Vol. total mensual") + 
  xlab("")

p2 <- ggplot(data = transacciones_mensuales) + 
  geom_line(aes(x = month, y = mean_volume)) +
  ylab("Vol. promedio diario") +
  xlab("")

p1 / p2
```

```{r}
# Opción 2

transacciones_mensuales %>% 
  pivot_longer(cols = c(monthly_volume, mean_volume),
               names_to = "variable", values_to = "valor") %>% 
  ggplot(aes(x = month, y = valor)) +
  geom_line() + ylab("Transacciones") + xlab("") +
  facet_wrap(~ variable, ncol = 1, scales = "free_y")
```

Vemos como tomando en cuenta el promedio de volumen por dias de calendario es mejor que el total de volumen.

```{r}
p <- global_economy %>% 
  filter(Country == "Mexico") %>% 
  pivot_longer(cols = -c(Country:Year)) %>% 
  ggplot(aes(x = Year, y = value)) +
  geom_line() + facet_wrap(~ name, scales = "free_y")

plotly::ggplotly(p)
```

## Ajustes poblacionales

Ejemplo: El PIB de algunos paises pueen reflejar un crecimiento falso debido a que no es proporcional, al tomar en cuenta la población (Per Capita), nos daremos cuenta que los datos anteriores son muy diferentes a la realidad.

```{r}
ge <- global_economy %>% 
  filter(Country == "Mexico" | Country == "Iceland" | Country == "Australia")
  # filter(Country %in% c("Mexico", "Iceland", "Australia"))

p3 <- ggplot(ge) + aes(x = Year, y = GDP, color = Country) + 
  geom_line()
 
p3
```

México ha tenido un mayor crecimiento en PIB que Australia e Islandia, vamos a ver como se ve tomando en cuenta la polación:

```{r}
ggplot(ge) + aes(x = Year, y = Population, color = Country) +
  geom_line()
```

```{r}
p4 <- ggplot(ge) + aes(x = Year, y = GDP / Population, color = Country) +
  geom_line() + ylab("GDP per capita")

p4
```

## Ajustes inflacionarios

Hay que tener en cuenta la tasa o indice de inflación al tratar el valor del dinero a lo largo del tiempo.

Si vemos las ventas de periodicos en Australia:

```{r}
print_retail <- aus_retail %>%
  filter(Industry == "Newspaper and book retailing") %>%
  group_by(Industry) %>%
  index_by(Year = year(Month)) %>%
  summarise(Turnover = sum(Turnover))
autoplot(print_retail)
```

Podemos ver que las ventas bajan a partir de 2010, tomando en cuenta la inflación:

```{r}
aus_economy <- global_economy %>%
  filter(Code == "AUS")
  # filter(Country == "Australia")

print_retail %>% 
  # unir las tablas print_retail y aus_economy con base en
  # print_retail
  left_join(aus_economy, by = "Year") %>%
  # calculando las ventas sin inflación
  mutate(Adjusted_turnover = Turnover / CPI) %>%
  #
  pivot_longer(
    cols            = c(Turnover, Adjusted_turnover),
    names_to        = "Type",
    values_to       = "Turnover",
    names_transform = list(Type = as_factor) 
  ) %>% 
  # gather es la versión vieja de pivot_longer, por lo tanto ya
  # no se recomienda utilizar
  # gather("Type", "Turnover", Turnover, Adjusted_turnover, factor_key = TRUE) %>%
  ggplot(aes(x = Year, y = Turnover)) +
    geom_line() +
    facet_grid(vars(Type), scales = "free_y") +
    xlab("Years") + ylab(NULL) +
    ggtitle("Turnover for the Australian print media industry")
```

Vemos que en realidad la caída ha sido más grande tomando en cuenta la inflación.

## Transformaciones matemáticas

Si la variación o estacionalidad de los datos aumenta o disminuye a lo largo del tiempo, tal vez sea buena idea aplicar una transformación matemática.

### Transformaciones logarítmicas

```{r}
data("JohnsonJohnson") 
autoplot(JohnsonJohnson)+
  ggtitle("Ventas trimestrales de J&J")
```

Podemos ver que la estacionalidad aumenta y es algo exponencial la gráfica. Podemos probar una transformación logarítmica para contrarestar esto. 

```{r}
autoplot(log(JohnsonJohnson)) +
  ggtitle("Logaritmo de las ventas trim. de J&J")
```

### Transformaciones de potencia

Sacar la raíz cuadrada o cúbica de los datos. $w_t = y_t^p$

```{r}
autoplot(JohnsonJohnson^(1/3)) +
  ggtitle("Logaritmo de las ventas trim. de J&J")
```

### Transformaciones Box-Cox

Familia de transformaciones matemáticas que incluye logaritmos y potencias. Funciona mediante un parámetro (lambda) Y trabaja así:

$w_t=$

${log(y_t), \text{ si }\lambda = 0}.$

$(y_t^\lambda-1)/\lambda, \text{ en otro caso}.$


El logaritmo simepre será natural si lambda es 0, si lambda es 1 solo se desplazará hacia abajo, en otro caso la gráfica cambiará su forma utilizando una potencia y un escalado simple. 

*Saber que valor de lambda usar:*

El mejor de lambda es aquel que hace la estacionalidad uniforme en la gráfica.

Ejemplos de diferentes valores:

```{r}
p5a <- aus_production %>% autoplot(Gas)+ 
  ggtitle("Producción de gas (datos reales)")

p5 <- aus_production %>% autoplot(box_cox(Gas,lambda = -0.5)) + ggtitle("Box-Cox, lambda = -0.5")

p6 <- aus_production %>% autoplot(box_cox(Gas,lambda = 0)) + ggtitle("Box-Cox, lambda = 0 (log)")

p7 <- aus_production %>% autoplot(box_cox(Gas,lambda = 0.1)) + ggtitle("Box-Cox, lambda = 0.1")

p8 <- aus_production %>% autoplot(box_cox(Gas,lambda = 1)) + ggtitle("Box-Cox, lambda = 1")

p5a
```

```{r}
(p5 | p6) / (p7 | p8)
```

### Guerrero 

Guerrero nos ayuda a seleccionar un valor automático de lambda:

```{r}
(lambda <- aus_production %>%
  features(Gas, features = guerrero) %>%
  pull(lambda_guerrero))
```

```{r}
aus_production %>% autoplot(box_cox(Gas, lambda))
```

# Componentes de las series de tiempo

Hay dos formas de descomponer la serie de tiempo:

- Aditiva
$$y_t = S_t + T_t + R_t$$
- Multiplicativa
$$y_t = S_t * T_t * R_t$$

Donde: 
- $S_t$ es el componente estacional
- $T_t$ es la tendencia-ciclo
- $R_t$ es el residuo


La aditiva es buena opción cuando la magnitud de la fluctuación estacional no cambia en el nivel de la serie. La multiplicativa para cuando sí cambia (como en series de tiempo económicas).

Una alternativa para la descomposición multiplicativa es transformar los datos para evitar la fluctuación en la estacionalidad y ahora poder usar aditiva, entonces tenemos que:

$$y_t = S_t * T_t * R_t \text{ es equivalente a } \log{y_t} = \log{S_t} + \log{T_t} + \log{R_t}$$


*Ejemplo de descomposición:*

```{r}
us_retail_employment <- us_employment %>%
  filter(year(Month) >= 1990, Title == "Retail Trade") %>%
  select(-Series_ID)

us_retail_employment
```

```{r}
us_retail_employment %>%
  autoplot(Employed) +
  xlab("Year") + ylab("Persons (thousands)") +
  ggtitle("Total employment in US retail")
```

Aplicando descomposisión STL:

```{r}
dcmp <- us_retail_employment %>%
  model(Descomposicion = STL(Employed))
components(dcmp)
```

Como podemos ver, esto separa los factores de la serie, viendo la tendencia:

```{r}
us_retail_employment %>%
  autoplot(Employed, color='gray') +
  autolayer(components(dcmp), trend, color='red') +
  xlab("Year") + ylab("Persons (thousands)") +
  ggtitle("Total employment in US retail")
```

Viendo los tres componentes (con escala):

```{r}
p <- components(dcmp) %>% autoplot() + xlab("Year")
plotly::ggplotly(p)
```


Datos de 2018:
```{r}
components(dcmp) %>% 
  as_tibble() %>% 
  mutate(Month = as.Date(Month)) %>% 
  filter(Month >= "2018-01-01") %>% 
  ggplot(aes(x = Month, y = Employed)) +
  geom_line() + xlab("Year") +
  scale_x_date(date_breaks = "1 month", date_labels = "%b %y") +
  theme(axis.text.x = element_text(angle = 90))
```

## Datos desestacionalizados

Muchas veces es util quitar el componente estacinal de una serie. A estos datos se les llama ajustados estacionalmente. Es usado en series como el desempleo o crecimiento económico donde no es importante o interesante ver la estacionalidad anual, sino los datos anuales solos. 

Los datos destacionalizados están dados por $y_t - S_t$ en aditiva y $\frac{y_t}{S_t}$ en multiplicativa.

Ejemplo con el empleo: 

```{r}
us_retail_employment %>%
  autoplot(Employed, color='gray') +
  autolayer(components(dcmp), season_adjust, color='blue') +
  xlab("Year") + ylab("Persons (thousands)") +
  ggtitle("Total employment in US retail")
```

# Medias móviles

Descomposición clásica usa medias móviles para definir y darle suacización a la tendencia.

Esto se obtiene al promediar los valores de la serie de tiempo dentro de $k$ periodos alrededor de $t$. Y se le llama media móvil de orden $m$. Donde $m = 2k +1$.


```{r}
p <- global_economy %>%
  filter(Country == "Mexico") %>%
  autoplot(Exports) +
  xlab("Year") + ylab("% of GDP") +
  ggtitle("Total Mexican exports")

plotly::ggplotly(p)
global_economy %>%
  filter(Country == "Mexico")
```

Vamos a aplicar una media móvil de orden 5, esto significa obtener el promedio de 5 periodos, para cada momento $t$. Por lo tanto, $m = 2k + 1 = 5$ y $k = 2$.

```{r}
mex_exports <- global_economy %>%
  filter(Country == "Mexico") %>%
  mutate(
    `5-MA` = slider::slide_dbl(Exports, mean, 
                               .before   = 2, 
                               .after    = 2,
                               .complete = TRUE)
  )

mex_exports
```

```{r}
# Opción 1
gg <- mex_exports %>%
  ggplot(aes(x = Year, y = Exports)) + 
  geom_line() +
  xlab("Year") + ylab("Exports (% of GDP)")
  
gg + geom_line(aes(y = `5-MA`), color='red') +
  ggtitle("Total Mexican exports & 5-MA")


# Opción 2
mex_exports %>% 
  autoplot(Exports) + 
  autolayer(mex_exports, `5-MA`, color = "red") +
  xlab("Year") + ylab("Exports (% of GDP)") +
  ggtitle("Total Mexican exports & 5-MA")
```

Podemos ver que la suavización captura el movimimento principal de la serie. 

Diferentes ordenes de media móvil y como afectará lo suave de la curva:

```{r}
mex_exports <- mex_exports %>%
  mutate(
    `1-MA` = slider::slide_dbl(Exports, mean, 
                               .before = 0, 
                               .after = 0, .complete = TRUE),
    `3-MA` = slider::slide_dbl(Exports, mean, 
                               .before = 1, 
                               .after = 1, .complete = TRUE),
    `7-MA` = slider::slide_dbl(Exports, mean, 
                               .before = 3, 
                               .after = 3, .complete = TRUE),
    `9-MA` = slider::slide_dbl(Exports, mean, 
                               .before = 4, 
                               .after = 4, .complete = TRUE),
    `11-MA` = slider::slide_dbl(Exports, mean, 
                                .before = 5, 
                                .after = 5, .complete = TRUE),
    `15-MA` = slider::slide_dbl(Exports, mean, 
                                .before = 7, 
                                .after = 7, .complete = TRUE),
    `17-MA` = slider::slide_dbl(Exports, mean, 
                                .before = 8, 
                                .after = 8, .complete = TRUE),
    `21-MA` = slider::slide_dbl(Exports, mean, 
                                .before = 10, 
                                .after = 10, .complete = TRUE)
  )


gg <- mex_exports %>%
  ggplot(aes(x = Year, y = Exports)) + 
  geom_line() +
  xlab("Year") + ylab("Exports (% of GDP)")

g1 <- gg +
 geom_line(aes(y = `1-MA`), color='red') +
  ggtitle("1-MA")
g3 <- gg +
 geom_line(aes(y = `3-MA`), color='red') +
  ggtitle("3-MA")
g5 <- gg +
 geom_line(aes(y = `5-MA`), color='red') +
  ggtitle("5-MA")
g7 <- gg +
 geom_line(aes(y = `7-MA`), color='red') +
  ggtitle("7-MA")
g9 <- gg +
 geom_line(aes(y = `9-MA`), color='red') +
  ggtitle("9-MA")
g11 <- gg +
 geom_line(aes(y = `11-MA`), color='red') +
  ggtitle("11-MA")
g15 <- gg +
 geom_line(aes(y = `15-MA`), color='red') +
  ggtitle("15-MA")
g17 <- gg +
 geom_line(aes(y = `17-MA`), color='red') +
  ggtitle("17-MA")
g21 <- gg +
 geom_line(aes(y = `21-MA`), color='red') +
  ggtitle("21-MA")

(g1 | g3 | g5) /
  (g7 | g9 | g11) /
  (g15 | g17 | g21)
```

```{r}
# Graficando las 6 series de una misma vez utilizando facetas
mex_exports %>% 
  pivot_longer(
    cols      = `5-MA`:`21-MA`,
    names_to  = "Orden",
    values_to = "Media móvil"
  ) %>% 
  ggplot(aes(x = Year, y = Exports)) + 
  geom_line() + 
  geom_line(aes(y = `Media móvil`), color = "red") +
  xlab("Año") + ylab("Exportaciones (% of PIB)") +
  facet_wrap(~ Orden) +
  theme_minimal()


```

## Medias móviles de medias móviles

A una suavizaciónd de media móvil se le puede aplicar una nueva suavizacióni de media móvil. 

Ejemplo: Sacar una media móvil de orden 4 y a eso sacarle la media móvi lde orden 2

```{r}
beer <- aus_production %>%
  filter(year(Quarter) >= 1992) %>%
  select(Quarter, Beer)

beer_ma <- beer %>%
  mutate(
    `4-MA` = slider::slide_dbl(Beer, mean, .before = 2, .after = 1, .complete = TRUE),
    `2x4-MA` = slider::slide_dbl(`4-MA`, mean, .before = 0, .after = 1, .complete = TRUE)
  )

beer_ma
```

Al sacar la media móvil de orden 4, tenemos:
$$\text{4-MA = }T_t=\frac{1}{4}(y_{t−2}+y_{t−1}+y_t+y_{t+1})$$

Al sacar media móvil de orden 2 a esta media móvil anterior:
$$\text{2×4-MA = }T_t=\frac{1}{2}[\frac{1}{4}(y_{t−2}+y_{t−1}+y_t+y_{t+1})+\frac{1}{4}(y_{t−1}+y_t+y_{t+1}+y_{t+2})]$$

Simplificando:
$$\text{2×4-MA = }T_t=\frac{1}{8}y_{t−2}+\frac{1}{4}y_{t−1}+\frac{1}{4}y_t+\frac{1}{4}y_{t+1}+\frac{1}{8}y_{t+2}$$

Por lo tanto, la media móvil de una media móvil es simplemente una media móvil ponderada. 

## medias móviles ponderadas

Entonces, una media móvil ponderada está constituida por dos o más medias móviles. 

Teniendo una media móvil de orden $m$ donde $k = (m-1)/2$, los pesos o ponderaciones están dados por $[a_{-k},...,a_k]$, los pesos deben sumar 1. 

Se puede decir que una media móvil simple m-MA es un caso particular de media móvil ponderada, donde todos sus pesos son iguales a $1/m$.


```{r}
us_retail_employment_ma <- us_retail_employment %>%
  mutate(
    `12-MA` = slider::slide_dbl(Employed, mean, .before = 6, .after = 5, .complete = TRUE),
    `2x12-MA` = slider::slide_dbl(`12-MA`, mean, .before = 0, .after = 1, .complete = TRUE)
  )

us_retail_employment_ma %>%
  autoplot(Employed, color='gray') +
  autolayer(us_retail_employment_ma, vars(`2x12-MA`), color='red') +
  xlab("Year") + ylab("Persons (thousands)") +
  ggtitle("Total employment in US retail, 2x12-MA")
```

# Métodos de descomposición

## Descomposición clásica. 

Dos tipos: aditiva y multiplicativa. Se asume que el componente estacional es constante a lo largo del tiempo. Es obsoleto, desventajas:

- No hay estimación de tendencia para las primeras y últimas observaciones.
- Asume que la estacionalidad se repite año con año, no captura cambios en ese patrón.

```{r}
us_retail_employment %>%
  model(classical_decomposition(Employed, type = "additive")) %>%
  components() %>%
  autoplot() + xlab("Year") +
  ggtitle("Classical additive decomposition of total US retail employment")
```

## Descomposición X11

Se basa en descomposición clásica con mejoras para atacar sus desventajas, funciona bien para datos trimestrales y mensuales. 

```{r}
x11_dcmp <- us_retail_employment %>%
  model(x11 = feasts:::X11(Employed, type = "additive")) %>%
  components()

autoplot(x11_dcmp) + xlab("Year") +
  ggtitle("Additive X11 decomposition of US retail employment in the US")
```

```{r}
x11_dcmp %>% 
  gg_season()
```

```{r}
x11_dcmp %>% 
  gg_subseries(seasonal)
```

## Descomposición SEATS

Seasonal Extraction Arima Time Series. Solo funciona para datos trimestrales o mensuales. 

```{r}
seats_dcmp <- us_retail_employment %>%
  model(seats = feasts:::SEATS(Employed)) %>%
  components()
autoplot(seats_dcmp) + xlab("Year") +
  ggtitle("SEATS decomposition of total US retail employment")
```

## Descomposición STL

Seasonal and Trend decomposition using loess (Loess es méotod de estimaciónd e realaciones no lineales).

Ventajas:
- Puede tratar con cualquier tipo de estacionalidad, no solo mensual o trimestral. 
- El componente estacional puede ariar con el tiempo.
- La suavización de tendencia es controlado por el usuario.
- Es robusto ante outliers. 

Desventajas: 
- No controla automáticamene la variación debido a días hábiles o variaciones por calendario. 
- Solo descomposiciones aditivas.

```{r}
us_retail_employment %>%
  model(STL(Employed ~ trend(window=7) + season(window='periodic'),
    robust = TRUE)) %>%
  components() %>%
  autoplot()
```

```{r}
# modificando la tendencia
us_retail_employment %>%
  model(STL(Employed ~ trend(window=15) + season(window='periodic'),
    robust = TRUE)) %>%
  components() %>%
  autoplot()
```

```{r}
# modificando la estacionalidad
us_retail_employment %>%
  model(STL(Employed ~ trend(window=7) + season(window=21),
    robust = TRUE)) %>%
  components() %>%
  autoplot()
```
Esta gráfica muestra una descomposición mediante STL, ajustando algunos parámetros (el componente de tendencia es más flexible, el componente estacional es fijo y se agregó la opción de robustez).

Los valores escogidos de los parámetros deben ser impares. Si se desea mantener el mismo componente estacional a lo largo del tiempo, se debería definir como periódico, season(window = "periodic"), como en el caso anterior.
